// /*
//  * 
//  */


//Working dec6 time 6:20pm 
#pragma once

#include "nvhls_pch.h"

SC_MODULE(Accelerator) {
public:
    sc_in_clk clk;
    sc_in<bool> rst;

    typedef sc_uint<64> AXI_DATA; // 64-bit AXI bus data type

    sc_out<sc_uint<8>> st_out;
    Connections::In<sc_uint<8>> ctrl_in;
    Connections::In<sc_uint<64>> w_in;
    Connections::In<sc_uint<64>> x_in;
    Connections::Out<sc_uint<64>> z_out;

    SC_HAS_PROCESS(Accelerator);

    Accelerator(sc_module_name name_) : sc_module(name_),
                                        st_out("st_out"),
                                        ctrl_in("ctrl_in"),
                                        w_in("w_in"),
                                        x_in("x_in"),
                                        z_out("z_out") {
        SC_THREAD(run);
        sensitive << clk.pos();
        NVHLS_NEG_RESET_SIGNAL_IS(rst);
    }

    // Helper function for packed output
    AXI_DATA assign_packed_output(AXI_DATA current_packed, sc_uint<16> value, int index) {
        #pragma HLS inline
        current_packed.range(index * 16 + 15, index * 16) = value;
        return current_packed;
    }

    void run() {
        ctrl_in.Reset();
        w_in.Reset();
        x_in.Reset();
        z_out.Reset();

        AXI_DATA data = 0;
        sc_uint<8> ctrl = 0;

// Buffer to store input samples
// Size: 80
// Reason: The FIR computations are divided into two segments:
// - The first segment (`TSTEP1`) processes 32 input samples.
// - The second segment (`TSTEP2`) processes 48 input samples.
// Total input samples required: TSTEP1 + TSTEP2 = 32 + 48 = 80.
// This buffer stores all input samples needed for both FIR computations.
sc_uint<16> input_data_buffer[80];

// Buffer to store filter weights
// Size: 32
// Reason: The FIR computations use two sets of weights:
// - The first set (`TAPS1`) consists of 16 weights for the first computation segment.
// - The second set (`TAPS2`) consists of another 16 weights for the second computation segment.
// Total weights required: TAPS1 + TAPS2 = 16 + 16 = 32.
// This buffer stores all filter weights needed for both FIR computations.
sc_uint<16> weight_data_buffer[32];

// Buffer to store computed output samples
// Size: 80
// Reason: The FIR computations produce output samples for each input segment:
// - The first segment (`TSTEP1`) produces 32 output samples.
// - The second segment (`TSTEP2`) produces 48 output samples.
// Total output samples generated: TSTEP1 + TSTEP2 = 32 + 48 = 80.
// This buffer stores all output samples generated by both FIR computations.
sc_uint<16> output_data_buffer[80];

        #pragma HLS array_partition variable=input_data_buffer cyclic factor=16 dim=1
        #pragma HLS array_partition variable=weight_data_buffer complete dim=1
        #pragma HLS array_partition variable=output_data_buffer cyclic factor=4 dim=1

        const AXI_DATA LOWER_16BIT_MASK = 0xFFFF; // Mask to extract 16-bit data chunks

        int input_index = 0;   // Tracks the position in the input buffer
        int weight_index = 0;  // Tracks the position in the weight buffer

        st_out.write(ctrl);
        wait(); // Wait separates reset from operational behavior

        while (1) {
            

    //         if (!w_in.Empty()) {
    //     data = w_in.Pop();

    //     // Directly extract all four 16-bit chunks and assign them in one step
    //     weight_data_buffer[weight_index++] = data.range(15, 0);     // Extract lower 16 bits
    //     weight_data_buffer[weight_index++] = data.range(31, 16);    // Extract next 16 bits
    //     weight_data_buffer[weight_index++] = data.range(47, 32);    // Extract third 16 bits
    //     weight_data_buffer[weight_index++] = data.range(63, 48);    // Extract upper 16 bits

    //     // Reset weight index when buffer is full
    //     if (weight_index == 32) {
    //         weight_index = 0;
    //     }

    //     // Push the original data for verification
    //     z_out.Push(data);
    // }
    if (!w_in.Empty()) {
    data = w_in.Pop();
    #pragma HLS pipeline II=1

    // Use a shift register approach for optimized extraction and assignment
    sc_uint<16> extracted_values[4]; // Temporary storage for extracted chunks
    #pragma HLS array_partition variable=extracted_values complete dim=1

    // Extract 16-bit chunks in parallel
    extracted_values[0] = data.range(15, 0);
    extracted_values[1] = data.range(31, 16);
    extracted_values[2] = data.range(47, 32);
    extracted_values[3] = data.range(63, 48);

    // Assign the extracted chunks to the weight buffer
    for (int i = 0; i < 4; i++) {
        #pragma HLS unroll
        weight_data_buffer[weight_index++] = extracted_values[i];

        // Reset weight index when buffer is full
        if (weight_index == 32) {
            weight_index = 0;
        }
    }

    z_out.Push(data); // Push the original data for verification
}
            


            else if (!x_in.Empty()) {
    data = x_in.Pop();

    // Unpack 16-bit chunks directly using range and parallel assignment
    #pragma HLS pipeline II=1
    input_data_buffer[input_index++] = data.range(15, 0);  // Extract bits 0-15
    input_data_buffer[input_index++] = data.range(31, 16); // Extract bits 16-31
    input_data_buffer[input_index++] = data.range(47, 32); // Extract bits 32-47
    input_data_buffer[input_index++] = data.range(63, 48); // Extract bits 48-63

    // Reset index if the buffer is full
    if (input_index == 80) {
        input_index = 0;
    }
}
            // Process control signals
            else if (!ctrl_in.Empty()) {
                ctrl = ctrl_in.Pop();

                if (ctrl == 0x2) { // Perform FIR computation for the first segment
                    perform_fir(32, 0, output_data_buffer, weight_data_buffer, input_data_buffer, z_out);
                    st_out.write(0x3); // Signal operation completion
                } else if (ctrl == 0x9) { // Perform FIR computation for the second segment
                    perform_fir(48, 32, output_data_buffer, &weight_data_buffer[16], &input_data_buffer[32], z_out);
                }
            }
            wait(); // Maintain timing and synchronization
        }
    }

private:
    void perform_fir(int compute_count, int output_offset,
                     sc_uint<16>* output_data_buffer,
                     sc_uint<16>* weight_data_buffer,
                     sc_uint<16>* input_data_buffer,
                     Connections::Out<AXI_DATA>& z_out) {
        #pragma HLS pipeline II=1
        int pack_index = 0;
        AXI_DATA packed_output = 0;

        optimize2: for (int n = 0; n < compute_count; n++) {
            #pragma HLS pipeline II=1
            output_data_buffer[output_offset + n] = 0;

            // FIR computation for a single output
            optimize1: for (int m = 0; m < 16; m++) {
                #pragma HLS unroll
                if (n + m - 16 + 1 >= 0) {
                    output_data_buffer[output_offset + n] +=
                        weight_data_buffer[m] * input_data_buffer[n + m - 16 + 1];
                }
            }

            packed_output = assign_packed_output(packed_output, output_data_buffer[output_offset + n], pack_index);
            pack_index++;

            if (pack_index == 4) {
                z_out.Push(packed_output);
                pack_index = 0;
                packed_output = 0; // Reset packed output for the next group
            }
        }

        if (pack_index > 0) {
            z_out.Push(packed_output);
        }
    }
};

